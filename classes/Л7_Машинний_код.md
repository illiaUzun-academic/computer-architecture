# Лекція №7 Машинний код

**План лекції:**

**1. Вступ:**

- Що таке машинний код?
- Чому важливо розуміти машинний код?
- Відмінність між машинним кодом та мовами програмування високого рівня.
- Історичний контекст: розвиток машинного коду та його роль у еволюції комп'ютерних технологій.

**2. Структура машинного коду:**

- Бінарна система числення: основа машинного коду.
- Одиниці вимірювання інформації: біт, байт, кілобайт, мегабайт тощо.
- Інструкції та операнди: основні компоненти машинного коду.
- Типи інструкцій: арифметичні, логічні, передачі даних, управління потоком тощо.
- Приклади простих інструкцій та їх представлення у машинному коді.

**3. Архітектура процесора та машинний код:**

- Роль процесора у виконанні машинного коду.
- Регістри процесора: їх призначення та використання.
- Стекова пам'ять: принцип роботи та роль у виконанні програм.
- Приклад виконання простої програми на рівні машинного коду з ілюстрацією роботи регістрів та стека.

**4. Практичні приклади:**

- Використання онлайн-симулятора/емулятора процесора для демонстрації виконання коду.
- Написання простої програми на асемблері (мові близькій до машинного коду) та аналіз її машинного коду.
- Використання дизасемблера для перегляду машинного коду існуючих програм.
- Аналіз прикладів машинного коду, взятих з реальних програм.



## Вступ: Що таке машинний код?

Машинний код – це набір інструкцій, які безпосередньо виконуються центральним процесором комп'ютера. Він є найнижчим рівнем програмування, представленим у вигляді двійкових чисел (нулів та одиниць), зрозумілих лише процесору.

Кожна інструкція машинного коду виконує елементарну операцію, наприклад:

- **Арифметичні операції:** додавання, віднімання, множення, ділення.
- **Логічні операції:** порівняння, перевірка умов.
- **Операції передачі даних:** переміщення даних між регістрами, пам'яттю та іншими пристроями.
- **Операції управління потоком:** перехід до іншої інструкції, виклик підпрограм, цикли.

Розуміння машинного коду важливе для:

- **Глибшого розуміння роботи комп'ютера:** вивчаючи машинний код, ми розуміємо, як процесор виконує програми на найнижчому рівні.
- **Оптимізації програм:** знання машинного коду дозволяє писати більш ефективний код, який виконується швидше та споживає менше ресурсів.
- **Зворотнього проектування та аналізу програм:** машинний код є основою для розуміння роботи програм без вихідного коду.
- **Розробки системного програмного забезпечення:** операційні системи, драйвери пристроїв та інше системне програмне забезпечення часто пишуть з використанням мов низького рівня, близьких до машинного коду.

Машинний код відрізняється від мов програмування високого рівня (таких як Python, Java, C++):

- **Складність:** машинний код важкий для читання та написання людьми, оскільки він представлений у вигляді двійкових чисел. Мови високого рівня використовують зрозуміліші для людини конструкції, такі як слова та символи.
- **Портативність:** машинний код залежить від конкретної архітектури процесора. Програми, написані на мовах високого рівня, можуть бути скомпільовані для різних платформ.
- **Абстракція:** мови високого рівня дозволяють програмістам зосередитися на логіці програми, абстрагуючись від деталей реалізації на рівні апаратного забезпечення.

Машинний код є основою роботи комп'ютерів, і розуміння його принципів є важливим для спеціалістів з інформатики та всіх, хто цікавиться глибшим розумінням технологій.



## Вступ: Чому важливо розуміти машинний код?

Хоча сучасні програмісти рідко пишуть код безпосередньо в машинному коді, розуміння його принципів та структури має ряд переваг:

**1. Глибше розуміння роботи комп'ютера:**

- **Виконання програм:** знання машинного коду дозволяє зрозуміти, як процесор інтерпретує інструкції, керує даними та взаємодіє з пам'яттю.
- **Оптимізація коду:** ви можете аналізувати, як компілятор перетворює код високого рівня на машинний код, та використовувати ці знання для написання більш ефективного коду.
- **Усунення несправностей:** розуміння машинного коду може допомогти в діагностиці та виправленні помилок, особливо тих, які виникають на низькому рівні.

**Приклад:** Аналізуючи машинний код програми, можна виявити неоптимальні цикли або зайві операції, що впливають на продуктивність. Змінивши код високого рівня відповідно, можна покращити ефективність програми.

**2. Зворотнє проектування та аналіз програм:**

- **Розуміння роботи програм без вихідного коду:** дизасемблювання машинного коду дозволяє дослідити логіку роботи програм, навіть якщо вихідний код недоступний.
- **Аналіз шкідливого програмного забезпечення:** знання машинного коду допомагає зрозуміти, як працює шкідливе програмне забезпечення, та розробити методи його виявлення та нейтралізації.

**Приклад:** Дослідники безпеки використовують дизасемблери для аналізу машинного коду вірусів та іншого шкідливого програмного забезпечення, щоб зрозуміти їх функціональність та розробити відповідні захисні заходи.

**3. Розробка системного програмного забезпечення:**

- **Операційні системи:** деякі частини операційних систем, наприклад, завантажувачі та драйвери пристроїв, часто пишуть на асемблері (мові близькій до машинного коду) для прямого управління апаратним забезпеченням.
- **Вбудовані системи:** для мікроконтролерів та інших вбудованих систем часто використовують машинний код або асемблер через обмежені ресурси та вимоги до ефективності.

**Приклад:** Розробка драйвера для нового пристрою може вимагати використання асемблера для прямого доступу до регістрів пристрою та управління його роботою.

**4. Освітні цілі:**

- **Розвиток логічного мислення:** вивчення машинного коду допомагає розвинути навички логічного мислення та розуміння алгоритмів.
- **Основа для вивчення інших дисциплін:** знання машинного коду є фундаментом для вивчення компіляторної техніки, архітектури комп'ютерів, операційних систем та інших дисциплін.

Навіть якщо ви не плануєте писати код на машинному коді, розуміння його основних принципів є цінним активом для будь-якого спеціаліста з інформатики, оскільки воно розширює ваші знання про роботу комп'ютерів та покращує ваші навички програмування.



## Історичний контекст: розвиток машинного коду та його роль у еволюції комп'ютерних технологій

Машинний код існує з моменту появи перших комп'ютерів. Спочатку програмування відбувалося шляхом ручного налаштування перемикачів та з'єднань, що відповідали інструкціям машинного коду.

**Ключові етапи розвитку машинного коду:**

- **1940-ві роки:** Перші комп'ютери, такі як ENIAC, програмувалися за допомогою патч-панелей та перемикачів. Кожна інструкція представлялася фізичним з'єднанням.
- **1950-ті роки:** З'явилися перші мови асемблера, які використовували мнемонічні коди для представлення інструкцій машинного коду. Це значно спростило програмування, оскільки програмістам більше не потрібно було запам'ятовувати двійкові коди.
- **1960-ті роки:** Розвиток мов програмування високого рівня, таких як Fortran та COBOL, дозволив програмістам зосередитися на логіці програми, а не на деталях роботи апаратного забезпечення. Компілятори перетворювали код високого рівня на машинний код, зрозумілий комп'ютеру.
- **1970-ті роки:** З'явилися мови програмування, такі як C, які поєднували елементи високого та низького рівня, надаючи програмістам більшу гнучкість та контроль над апаратним забезпеченням.
- **1980-ті роки – до сьогодні:** Розвиток потужних компіляторів та інтерпретаторів зробив мови високого рівня ще ефективнішими та зручнішими для розробки складних програм.

**Роль машинного коду в еволюції комп'ютерних технологій:**

- **Фундамент програмування:** машинний код є основою, на якій побудовані всі інші мови програмування. Розуміння машинного коду дозволяє глибше зрозуміти, як працюють комп'ютери та програмне забезпечення.
- **Оптимізація та ефективність:** знання машинного коду дозволяє оптимізувати програми для максимальної продуктивності.
- **Розвиток нових технологій:** машинний код відіграє важливу роль у розробці нових технологій, таких як штучний інтелект, віртуальна реальність та вбудовані системи.

Хоча сьогодні більшість програм пишуть на мовах високого рівня, машинний код залишається важливою частиною комп'ютерних технологій. Розуміння його принципів допомагає програмістам писати більш ефективний код, аналізувати програми та розвивати нові технології.



## Структура машинного коду: Бінарна система числення

Машинний код побудований на основі бінарної системи числення, яка використовує лише два символи: 0 та 1. Ці символи, що називаються бітами (binary digit), представляють два можливі стани електричного сигналу: низький (0) або високий (1).

**Чому бінарна система?**

- **Простота:** бінарна система є найпростішою системою числення, що робить її ідеальною для представлення станів електронних компонентів (транзисторів), які можуть бути або ввімкнені (1), або вимкнені (0).
- **Надійність:** бінарні сигнали менш схильні до помилок та спотворень, ніж сигнали з більшою кількістю станів.
- **Логічні операції:** бінарна система дозволяє легко виконувати логічні операції (І, АБО, НЕ), які є основою роботи комп'ютера.

**Представлення чисел у бінарній системі:**

- Кожна цифра в бінарному числі називається бітом.
- Значення кожного біта визначається його позицією (розрядом) у числі.
- Найправіший біт має найменшу вагу (2^0 = 1), а вага кожного наступного біта подвоюється (2^1, 2^2, 2^3 тощо).
- Для перетворення бінарного числа в десяткове, потрібно помножити значення кожного біта на його вагу та скласти результати.

**Приклад:**

Бінарне число 1011 представляє десяткове число 11:

```
1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 8 + 0 + 2 + 1 = 11
```

**Бінарна система є основою для представлення всіх даних у комп'ютері, включаючи числа, текст, зображення та інструкції машинного коду.**



## Одиниці вимірювання інформації

У світі комп'ютерів інформація вимірюється в спеціальних одиницях, що базуються на бінарній системі числення:

- **Біт (bit):** це найменша одиниця інформації, яка може приймати значення 0 або 1.
- **Байт (byte):** складається з 8 бітів і є основною одиницею вимірювання інформації. Один байт може представляти 256 різних значень (2^8).
- **Кілобайт (KB):** дорівнює 1024 байтам (2^10).
- **Мегабайт (MB):** дорівнює 1024 кілобайтам (2^20).
- **Гігабайт (GB):** дорівнює 1024 мегабайтам (2^30).
- **Терабайт (TB):** дорівнює 1024 гігабайтам (2^40).

**Приклади використання одиниць інформації:**

- Розмір файлу зображення може вимірюватися в мегабайтах.
- Об'єм оперативної пам'яті комп'ютера вимірюється в гігабайтах.
- Швидкість передачі даних в інтернеті вимірюється в мегабітах за секунду (Mbps).

**Префікси для великих одиниць:**

Для позначення дуже великих обсягів інформації використовуються префікси:

- **Кіло (K):** 10^3 (тисяча)
- **Мега (M):** 10^6 (мільйон)
- **Гіга (G):** 10^9 (мільярд)
- **Тера (T):** 10^12 (трильйон)

**Важливо зазначити, що в контексті комп'ютерів ці префікси часто використовуються з базою 2 (1024), а не з базою 10 (1000).**

Розуміння одиниць вимірювання інформації є важливим для роботи з комп'ютерами та цифровими даними.



## Інструкції та операнди: основні компоненти машинного коду

Машинний код складається з послідовності інструкцій, які процесор виконує одна за одною. Кожна інструкція складається з двох основних компонентів:

- **Opcode (код операції):** визначає тип операції, яку потрібно виконати. Це може бути арифметична операція (наприклад, додавання), логічна операція (наприклад, порівняння), операція передачі даних (наприклад, копіювання) або операція управління потоком (наприклад, перехід). Код операції представлений унікальним бінарним кодом, який розпізнається процесором.
- **Операнди:** визначають дані, над якими виконується операція. Операндами можуть бути:
  - **Значення:** безпосередньо вказані в інструкції (наприклад, число 5).
  - **Адреси:** вказують на місцезнаходження даних у пам'яті або регістрах процесора.
  - **Регістри:** спеціальні комірки пам'яті всередині процесора, які використовуються для зберігання проміжних результатів та даних.

**Структура інструкції:**

Структура інструкції залежить від конкретної архітектури процесора. Однак, загальна структура зазвичай виглядає так:

```
[opcode] [operand1] [operand2] ...
```

**Приклад:**

Інструкція, яка додає два числа та зберігає результат у регістрі, може мати таку структуру:

```
ADD R1, R2, R3
```

Де:

- **ADD** - код операції для додавання.
- **R1** - регістр, куди буде записаний результат.
- **R2** та **R3** - регістри, які містять числа, що додаються.

**Інструкції та операнди є основними будівельними блоками машинного коду, які визначають, які дії виконує процесор.**



## Типи інструкцій

Інструкції машинного коду можна поділити на кілька основних типів залежно від їх функції:

**1. Арифметичні інструкції:**

- Виконують арифметичні операції над числами, такими як додавання, віднімання, множення, ділення та обчислення залишку від ділення.
- **Приклади:** ADD (додавання), SUB (віднімання), MUL (множення), DIV (ділення), MOD (залишок від ділення).

**2. Логічні інструкції:**

- Виконують логічні операції над бітами, такі як І, АБО, НЕ, XOR (виключна диз'юнкція) та побітове зсунення.
- **Приклади:** AND, OR, NOT, XOR, SHL (зсув вліво), SHR (зсув вправо).

**3. Інструкції передачі даних:**

- Переміщують дані між регістрами процесора, пам'яттю та іншими пристроями.
- **Приклади:** MOV (копіювання), PUSH (запис у стек), POP (читання зі стека), LOAD (завантаження з пам'яті), STORE (збереження в пам'ять).

**4. Інструкції управління потоком:**

- Змінюють послідовність виконання інструкцій, дозволяючи створювати цикли, умовні переходи та виклики підпрограм.
- **Приклади:** JMP (безумовний перехід), JZ (перехід за нулем), JNZ (перехід за ненулем), CALL (виклик підпрограми), RET (повернення з підпрограми).

**5. Інші інструкції:**

- Існують також інші типи інструкцій, які виконують специфічні функції, такі як робота з числами з плаваючою комою, введення-виведення, керування системою тощо.

**Різноманітність інструкцій дозволяє програмістам створювати складні алгоритми та програми, які виконують різні завдання.**



## Приклади простих інструкцій та їх представлення у машинному коді

Представлення інструкцій у машинному коді залежить від конкретної архітектури процесора. Однак, для ілюстрації наведемо спрощені приклади:

**1. Інструкція ADD (додавання):**

- **Функція:** додає два числа.
- **Формат:** ADD dst, src1, src2
- **Опис:** додає значення src1 та src2, і записує результат у dst.
- **Приклад (уявний машинний код):**
  - Opcode (ADD): 0001
  - Регістр dst: 01 (регістр R1)
  - Регістр src1: 10 (регістр R2)
  - Регістр src2: 11 (регістр R3)
- **Результат:** 0001 01 10 11

**2. Інструкція MOV (копіювання):**

- **Функція:** копіює значення з одного місця в інше.
- **Формат:** MOV dst, src
- **Опис:** копіює значення src у dst.
- **Приклад (уявний машинний код):**
  - Opcode (MOV): 0010
  - Регістр dst: 01 (регістр R1)
  - Значення src: 1101 (число 13)
- **Результат:** 0010 01 1101

**3. Інструкція JMP (безумовний перехід):**

- **Функція:** переходить до іншої інструкції.
- **Формат:** JMP address
- **Опис:** змінює поточну позицію виконання на address.
- **Приклад (уявний машинний код):**
  - Opcode (JMP): 0100
  - Адреса address: 1010 (адреса інструкції)
- **Результат:** 0100 1010

**Це спрощені приклади, і реальний машинний код може бути значно складнішим, залежно від архітектури процесора та типу інструкції.**

**Важливо зазначити, що програмісти рідко пишуть код безпосередньо у машинному коді. Зазвичай, вони використовують мови асемблера або мови високого рівня, які потім компілюються в машинний код.**



## Архітектура процесора та машинний код: Роль процесора у виконанні коду

Центральний процесор (CPU) – це мозок комп'ютера, який відповідає за виконання інструкцій машинного коду. Він складається з кількох основних компонентів, що взаємодіють для обробки даних та виконання програм:

**1. Арифметико-логічний пристрій (ALU):**

- Виконує арифметичні (додавання, віднімання, множення, ділення) та логічні (І, АБО, НЕ) операції над даними.
- Отримує дані з регістрів, виконує операції та записує результат назад у регістр або пам'ять.

**2. Блок керування (CU):**

- Керує послідовністю виконання інструкцій.
- Зчитує інструкції з пам'яті, декодує їх (визначає код операції та операнди) та відправляє відповідні сигнали до інших компонентів процесора для виконання операції.
- Керує потоком даних між ALU, регістрами та пам'яттю.

**3. Регістри:**

- Це невеликі, високошвидкісні комірки пам'яті всередині процесора, які використовуються для зберігання даних, з якими процесор працює в даний момент.
- Різні типи регістрів мають різні призначення:
  - **Регістр даних:** зберігають дані, над якими виконуються операції.
  - **Адресный регістр:** зберігають адреси пам'яті.
  - **Регістр команд:** зберігає адресу наступної інструкції, яку потрібно виконати.
  - **Регістр прапорів:** зберігають інформацію про результати операцій (наприклад, чи є результат нулем, від'ємним тощо).

**4. Кеш-пам'ять:**

- Це швидка, проміжна пам'ять між процесором та основною пам'яттю, яка зберігає копії часто використовуваних даних для прискорення доступу до них.

**Процес виконання машинного коду:**

1. **Завантаження інструкції:** Блок керування зчитує інструкцію з пам'яті та завантажує її в регістр команд.
2. **Декодування:** Блок керування декодує інструкцію, визначаючи код операції та операнди.
3. **Вибірка операндів:** Блок керування вибирає операнди з регістрів або пам'яті.
4. **Виконання:** ALU виконує операцію, визначену кодом операції, над операндами.
5. **Збереження результату:** Результат операції записується в регістр або пам'ять.
6. **Перехід до наступної інструкції:** Блок керування переходить до наступної інструкції, адреса якої зберігається в регістрі команд, і цикл повторюється.

**Архітектура процесора та набір доступних інструкцій визначають, який машинний код може бути виконаний на цьому процесорі.**



## Регістри процесора: їх призначення та використання

Регістри – це високошвидкісні комірки пам'яті всередині процесора, які використовуються для тимчасового зберігання даних, з якими процесор працює в даний момент. Вони грають ключову роль у виконанні машинного коду, забезпечуючи швидкий доступ до даних та підвищуючи ефективність роботи процесора.

**Типи регістрів:**

- **Регістри загального призначення (GPR):** використовуються для зберігання даних різних типів, таких як цілі числа, адреси пам'яті та проміжні результати обчислень. Кількість та розмір GPR залежать від архітектури процесора.
- **Регістр команд (PC):** зберігає адресу наступної інструкції, яку потрібно виконати. Після виконання кожної інструкції значення PC збільшується на розмір інструкції, щоб вказати на наступну інструкцію в послідовності.
- **Регістр прапорів (FLAGS):** зберігають інформацію про результат останньої операції, наприклад, чи є результат нулем, від'ємним, чи стався переповнення тощо. Ці прапори використовуються інструкціями управління потоком для прийняття рішень про переходи та цикли.
- **Сегментні регістри:** використовуються в деяких архітектурах для керування сегментацією пам'яті. Вони вказують на початок та кінець сегментів пам'яті, що дозволяє процесору працювати з великими обсягами пам'яті.
- **Інші спеціальні регістри:** деякі архітектури мають додаткові регістри для виконання специфічних функцій, таких як робота з числами з плаваючою комою, управління системою тощо.

**Використання регістрів:**

- **Зберігання операндів:** регістри використовуються для зберігання операндів інструкцій, що дозволяє ALU швидко отримувати доступ до даних та виконувати операції.
- **Зберігання проміжних результатів:** під час виконання складних обчислень регістри використовуються для зберігання проміжних результатів, що дозволяє уникнути зайвих звернень до пам'яті.
- **Передача параметрів:** регістри можуть використовуватися для передачі параметрів підпрограмам.
- **Збереження стану програми:** регістри використовуються для зберігання інформації про поточний стан програми, такої як значення змінних та адреса повернення з підпрограми.

**Ефективне використання регістрів є важливим аспектом оптимізації коду та підвищення продуктивності програми.**



## Стекова пам'ять: принцип роботи та роль у виконанні програм

Стекова пам'ять (стек) – це область пам'яті, організована за принципом "останнім прийшов, першим вийшов" (LIFO). Вона використовується для тимчасового зберігання даних під час виконання програми, наприклад:

- **Локальні змінні підпрограм:** коли викликається підпрограма, її локальні змінні розміщуються в стеку. Після завершення підпрограми ці змінні видаляються зі стеку.
- **Параметри підпрограм:** при виклику підпрограми значення параметрів також розміщуються в стеку.
- **Адреса повернення:** коли відбувається виклик підпрограми, адреса наступної інструкції після виклику (адреса повернення) зберігається в стеку. Це дозволяє повернутися до правильного місця в програмі після завершення підпрограми.
- **Збереження стану процесора:** при перериванні або виклику підпрограми, вміст деяких регістрів процесора може бути збережений у стеку для подальшого відновлення.

**Принцип роботи стеку:**

- Стек має "верхівку" (top) та "дно" (bottom).
- Дані додаються до стеку за допомогою операції "push". Новий елемент розміщується на верхівці стеку, а верхівка переміщується на одну позицію вгору.
- Дані витягуються зі стеку за допомогою операції "pop". Елемент з верхівки стеку витягується, а верхівка переміщується на одну позицію вниз.

**Роль стеку у виконанні програм:**

- **Управління підпрограмами:** стек забезпечує механізм для зберігання локальних змінних, параметрів та адреси повернення під час виклику підпрограм.
- **Обробка переривань:** при виникненні переривання, поточний стан процесора (вміст регістрів) зберігається в стеку, щоб програма могла відновити виконання після обробки переривання.
- **Динамічне виділення пам'яті:** в деяких мовах програмування стек використовується для динамічного виділення пам'яті під час виконання програми.

**Ефективне використання стеку є важливим для забезпечення правильної роботи програм та керування ресурсами пам'яті.**



## Приклад виконання програми на рівні машинного коду

Для ілюстрації роботи регістрів та стека розглянемо спрощений приклад програми, яка обчислює суму двох чисел та виводить результат на екран.

**Припущення:**

- Використовується спрощена архітектура процесора з 4 регістрами загального призначення (R1-R4), регістром команд (PC) та стеком.
- Інструкції мають фіксований розмір 1 байт.
- Для виведення результату використовується спеціальна інструкція PRINT, яка приймає один операнд – регістр, що містить число, яке потрібно вивести.

**Програма:**

1. Зчитати перше число з вводу та зберегти його в регістрі R1.
2. Зчитати друге число з вводу та зберегти його в регістрі R2.
3. Додати числа з R1 та R2, і зберегти результат в R3.
4. Вивести значення R3 на екран.

**Машинний код програми (уявний):**

```
Addr  Інструкція
00    READ R1      ; Зчитати перше число в R1
01    READ R2      ; Зчитати друге число в R2
02    ADD R3, R1, R2 ; Додати R1 та R2, результат в R3
03    PRINT R3     ; Вивести значення R3
```

**Виконання програми крок за кроком:**

1. **PC = 00:** Процесор зчитує інструкцію READ R1 з адреси 00. Інструкція зчитує число з вводу (наприклад, 5) та зберігає його в R1. PC збільшується на 1 (PC = 01).
2. **PC = 01:** Процесор зчитує інструкцію READ R2 з адреси 01. Інструкція зчитує число з вводу (наприклад, 3) та зберігає його в R2. PC збільшується на 1 (PC = 02).
3. **PC = 02:** Процесор зчитує інструкцію ADD R3, R1, R2 з адреси 02. ALU додає значення R1 (5) та R2 (3), і записує результат (8) в R3. PC збільшується на 1 (PC = 03).
4. **PC = 03:** Процесор зчитує інструкцію PRINT R3 з адреси 03. Інструкція виводить значення R3 (8) на екран. PC збільшується на 1 (PC = 04).
5. **PC = 04:** Програма завершена.

**Роль регістрів:**

- R1 та R2 зберігають вхідні числа.
- R3 зберігає результат додавання.
- PC відстежує поточну інструкцію.

**Роль стека:**

- У цьому простому прикладі стек не використовується. Однак, у складніших програмах він міг би використовуватися для зберігання локальних змінних, параметрів підпрограм та адреси повернення.

**Цей приклад демонструє, як процесор виконує інструкції машинного коду крок за кроком, використовуючи регістри для зберігання даних та керування процесом виконання.**



## Використання онлайн-симулятора/емулятора процесора

Онлайн-симулятори та емулятори процесора – це інструменти, які дозволяють візуалізувати та досліджувати виконання машинного коду в інтерактивному середовищі. Вони емулюють роботу реального процесора, дозволяючи вам:

- **Вводити машинний код:** ви можете вводити інструкції машинного коду або асемблерного коду, який потім буде перетворений на машинний код.
- **Виконувати код крок за кроком:** ви можете виконувати код інструкція за інструкцією, спостерігаючи за змінами в регістрах, пам'яті та інших компонентах процесора.
- **Переглядати стан процесора:** ви можете переглядати поточні значення регістрів, вміст пам'яті, прапори та інші параметри процесора.
- **Налагоджувати код:** ви можете використовувати симулятор/емулятор для пошуку та виправлення помилок у вашому коді.

**Популярні онлайн-симулятори/емулятори процесора:**

- **Little Man Computer (LMC):** простий симулятор, який емулює гіпотетичний комп'ютер з обмеженим набором інструкцій.
- **Online 8086 Emulator:** емулятор процесора Intel 8086, який був популярний у 1980-х роках.
- **JavaScript CPU Emulator:** емулятор процесора, написаний на JavaScript, який може бути вбудований у веб-сторінки.
- **Visual6502:** емулятор процесора MOS 6502, який використовувався в багатьох домашніх комп'ютерах та ігрових консолях у 1980-х роках.

**Використання симулятора/емулятора на лекції:**

1. **Виберіть симулятор/емулятор, який відповідає вашим потребам.** Для початківців підійде LMC, оскільки він має простий інтерфейс та обмежений набір інструкцій.
2. **Введіть приклад програми на машинному коді або асемблерному коді.** Ви можете використовувати приклад, який ми розглянули раніше, або написати свій власний код.
3. **Виконайте код крок за кроком.** Спостерігайте за змінами в регістрах, пам'яті та інших компонентах процесора.
4. **Пояснюйте студентам, що відбувається на кожному кроці.** Зосередьтеся на ролі регістрів, стека та інших компонентів процесора у виконанні програми.
5. **Заохочуйте студентів до експериментів.** Нехай вони змінюють код та спостерігають за результатами, щоб глибше зрозуміти принципи роботи машинного коду.

**Використання онлайн-симулятора/емулятора процесора є чудовим способом зробити лекцію про машинний код більш інтерактивною та наочною.**



## Написання простої програми на асемблері та аналіз її машинного коду

Для демонстрації напишемо просту програму на асемблері, яка обчислює суму двох чисел та виводить результат на екран.

**Вибір асемблера:**

Існує багато різних діалектів асемблера, залежно від архітектури процесора. Для цього прикладу ми будемо використовувати NASM (Netwide Assembler), який є популярним асемблером для архітектури x86.

**Програма на асемблері:**

```
section .text
    global _start

_start:
    mov eax, 5    ; Зберігаємо перше число (5) в регістрі eax
    mov ebx, 3    ; Зберігаємо друге число (3) в регістрі ebx
    add eax, ebx  ; Додаємо ebx до eax (результат 8 в eax)

    ; Підготовка до виводу
    mov ecx, msg  ; Адреса рядка для виводу в ecx
    mov edx, len   ; Довжина рядка в edx
    mov eax, 4    ; Код системного виклику для виводу (sys_write)
    mov ebx, 1    ; Дескриптор файлу для виводу (stdout)
    int 0x80      ; Виклик ядра операційної системи

    ; Завершення програми
    mov eax, 1    ; Код системного виклику для завершення (sys_exit)
    mov ebx, 0    ; Код повернення (0)
    int 0x80      ; Виклик ядра операційної системи

section .data
    msg db "Сума: ", 0 ; Рядок для виводу
    len equ $ - msg     ; Довжина рядка
```

**Аналіз машинного коду:**

Для перегляду машинного коду, згенерованого асемблером, можна використовувати дизасемблер. Наприклад, в Linux можна скористатися командою objdump:

```
objdump -d program.o
```

Де program.o - це об'єктний файл, згенерований асемблером.

**Приклад виводу дизасемблера (спрощений):**

```
00000000 <_start>:
   0:   b8 05 00 00 00          mov    eax,0x5
   5:   bb 03 00 00 00          mov    ebx,0x3
   a:   01 d8                   add    eax,ebx
   ...
  16:   b8 04 00 00 00          mov    eax,0x4
  1b:   bb 01 00 00 00          mov    ebx,0x1
  20:   cd 80                   int    0x80
  ...
```

**У виводі дизасемблера ми бачимо машинний код, що відповідає інструкціям асемблера. Наприклад, інструкція mov eax, 5 перетворилася на код b8 05 00 00 00.**

**Цей приклад демонструє, як програма на асемблері перетворюється на машинний код, який може бути виконаний процесором.**

**Важливо зазначити, що аналіз машинного коду може бути складним завданням, особливо для складних програм. Однак, розуміння основних принципів та використання дизасемблера можуть допомогти вам зрозуміти, як працюють програми на низькому рівні.**



## Використання дизасемблера для перегляду машинного коду

Дизасемблер – це інструмент, який перетворює машинний код (двійковий код) на асемблерний код, що більш зрозумілий для людини. Він дозволяє досліджувати логіку роботи програм, аналізувати шкідливе програмне забезпечення та розуміти, як програми взаємодіють з апаратним забезпеченням.

**Популярні дизасемблери:**

- **IDA Pro:** потужний комерційний дизасемблер з широкими можливостями аналізу та налагодження.
- **Ghidra:** безкоштовний дизасемблер з відкритим вихідним кодом, розроблений Агентством національної безпеки США (NSA).
- **objdump:** утиліта дизасемблювання, що входить до складу GNU Binutils. Вона доступна в більшості дистрибутивів Linux.
- **otool:** утиліта дизасемблювання для macOS.

**Як використовувати дизасемблер:**

2. **Виберіть дизасемблер:** вибір залежить від ваших потреб та операційної системи.
3. **Завантажте програму в дизасемблер:** більшість дизасемблерів дозволяють відкривати виконувані файли (EXE, ELF, Mach-O) або об'єктні файли (OBJ).
4. **Досліджуйте асемблерний код:** дизасемблер покаже вам асемблерний код, що відповідає машинному коду програми. Ви можете переглядати інструкції, дані, переходи та інші елементи програми.
5. **Використовуйте функції аналізу:** багато дизасемблерів пропонують функції аналізу, такі як граф викликів, перехресні посилання, визначення типів даних та інші, які допомагають зрозуміти логіку роботи програми.

**Приклади використання дизасемблера:**

- **Аналіз шкідливого програмного забезпечення:** дослідники безпеки використовують дизасемблери для аналізу шкідливого коду, щоб зрозуміти його функціональність, виявити вразливості та розробити методи захисту.
- **Зворотнє проектування:** дизасемблери використовуються для зворотного проектування програм, щоб зрозуміти їх алгоритми, структуру даних та інші деталі реалізації.
- **Налагодження:** дизасемблери можуть допомогти в налагодженні програм, особливо коли вихідний код недоступний або коли виникають проблеми на низькому рівні.
- **Освіта:** дизасемблери використовуються в освітніх цілях для вивчення асемблера, архітектури комп'ютерів та принципів роботи програмного забезпечення.

**Використання дизасемблера вимагає певних знань асемблера та архітектури процесора. Однак, це потужний інструмент для дослідження програмного забезпечення та розуміння його роботи на низькому рівні.**



## Аналіз прикладів машинного коду з реальних програм

Аналізувати машинний код з реальних програм – складне завдання, яке вимагає знань асемблера, архітектури процесора та принципів роботи програмного забезпечення. Однак, розглянемо спрощений приклад для демонстрації процесу.

**Приклад:**

Візьмемо фрагмент машинного коду з програми, написаної для архітектури x86:

```
8B 45 FC      mov eax, [ebp-0x4]  ; Зчитуємо значення змінної з стеку
01 C0         add eax, eax       ; Додаємо значення до себе (множимо на 2)
89 45 F8      mov [ebp-0x8], eax ; Зберігаємо результат назад у сек
```

**Аналіз:**

1. **8B 45 FC (mov eax, [ebp-0x4]):**
   - 8B – код операції для інструкції mov.
   - 45 FC – операнд, що вказує на адресу пам'яті. ebp – регістр, що вказує на основу стекового кадру поточної функції. FC (у шістнадцятковій системі) дорівнює -4 у десятковій системі, тобто інструкція зчитує значення змінної, розташованої на 4 байти вище від верхівки стека.
2. **01 C0 (add eax, eax):**
   - 01 – код операції для інструкції add.
   - C0 – другий операнд, який вказує на регістр eax. Інструкція додає значення з eax до самого себе, що еквівалентно множенню на 2.
3. **89 45 F8 (mov [ebp-0x8], eax):**
   - 89 – код операції для інструкції mov.
   - 45 F8 – операнд, що вказує на адресу пам'яті. Інструкція зберігає значення з регістру eax у змінну, розташовану на 8 байтів вище від верхівки стека.

**Висновок:**

Цей фрагмент коду зчитує значення змінної з стека, множить його на 2 та зберігає результат назад у стек. Це може бути частиною більшого алгоритму, який виконує обчислення над даними.

**Інструменти для аналізу:**

- **Дизасемблери:** IDA Pro, Ghidra, objdump, otool
- **Налагоджувачі:** gdb, lldb, WinDbg
- **Онлайн-ресурси:** довідники з інструкцій процесора, документація з асемблера

**Важливо зазначити, що аналіз машинного коду вимагає досвіду та знань. Для складних програм може знадобитися використання різних інструментів та технік аналізу.**
