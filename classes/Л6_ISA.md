# Лекція №6 Архітектури наборів інструкцій (ISA)

### Основи архітектури наборів інструкцій (ISA)

1. **Що таке ISA?** - Визначення та роль ISA у комп'ютерній архітектурі.
2. **Типи ISA** - RISC проти CISC, їх відмінності та застосування.

### Порівняння різних ISA

1. **Огляд та порівняння ISA** - Детальне порівняння між x86, ARM, MIPS з акцентом на їх особливості та сфери застосування.
2. **Вплив ISA на продуктивність та оптимізацію** - Як різні ISA впливають на проектування систем і оптимізацію програмного забезпечення.

### Компоненти та функції наборів інструкцій

1. **Типи інструкцій** - Розгляд різних типів інструкцій: арифметичні, логічні, керування переходами та доступу до даних.
2. **Формати інструкцій** - Структура інструкцій: операнди, опкоди і їх вплив на виконання.
3. **Режими адресації** - Методи звернення до даних в інструкціях: прямий, непрямий, індексний та ін.



ISA, або Архітектура Набору Інструкцій, є фундаментальною частиною комп'ютерної архітектури, що визначає набір інструкцій, які процесор може виконувати. Вона слугує інтерфейсом між апаратним забезпеченням і програмним забезпеченням, дозволяючи програмам керувати апаратними ресурсами комп'ютера.

ISA охоплює визначення типів даних, інструкцій, регістрів, адресаційних мод, пам'яті та вхід/вихідних операцій. Ця архітектура визначає, які операції комп'ютер може виконувати (наприклад, арифметичні, логічні операції, керування потоком програми) та яким чином ці операції будуть виконуватися, включаючи представлення чисел, кодування інструкцій та механізми виклику функцій.

Існують різні типи ISA, зокрема RISC (Reduced Instruction Set Computing - Обчислення зі скороченим набором інструкцій) та CISC (Complex Instruction Set Computing - Обчислення з комплексним набором інструкцій). RISC зосереджується на спрощенні інструкцій для покращення швидкості їх виконання, тоді як CISC використовує більш складні інструкції, які можуть виконувати кілька операцій за один такт.

Розуміння ISA є ключовим для проектування ефективного апаратного та програмного забезпечення, оскільки воно впливає на оптимізацію програм, вибір алгоритмів, та загальну продуктивність системи. ISA слугує мостом між програмним забезпеченням, що розробляється, та апаратним забезпеченням, на якому це програмне забезпечення виконується, дозволяючи розробникам ефективно використовувати можливості комп'ютерної системи.

Для порівняння різних архітектур наборів інструкцій (ISA) розглянемо два основних типи ISA, які домінують у світі комп'ютерних архітектур: RISC (Reduced Instruction Set Computing — Обчислення зі скороченим набором інструкцій) і CISC (Complex Instruction Set Computing — Обчислення з комплексним набором інструкцій), а також звернемо увагу на VLIW (Very Long Instruction Word) і EPIC (Explicitly Parallel Instruction Computing), щоб показати різноманіття підходів до проектування ISA.

### RISC (Reduced Instruction Set Computing)

**Основні характеристики:**

- Скорочений набір інструкцій.
- Інструкції фіксованої довжини, що спрощує декодування інструкцій.
- Наголос на використанні регістрів всередині процесора для операцій.
- Висока швидкість виконання завдяки спрощеному пайплайнінгу.

**Приклади архітектур:** ARM, MIPS, RISC-V

### CISC (Complex Instruction Set Computing)

**Основні характеристики:**

- Комплексний набір інструкцій з інструкціями різної довжини.
- Інструкції можуть виконувати кілька операцій.
- Ефективне використання пам'яті завдяки можливості здійснення складних операцій в одній інструкції.
- Може вимагати складнішого апаратного забезпечення для декодування та виконання інструкцій.

**Приклади архітектур:** x86, IBM System/360

### VLIW (Very Long Instruction Word)

**Основні характеристики:**

- Інструкції дуже великої довжини, які містять кілька операндів.
- Спрямовані на максимальне використання паралелізму на рівні інструкцій.
- Потребує компіляторів, які можуть ефективно генерувати використання цього паралелізму.

**Приклади архітектур:** Intel Itanium (частково використовує EPIC)

### EPIC (Explicitly Parallel Instruction Computing)

**Основні характеристики:**

- Розроблена для явного вказування паралелізму на рівні інструкцій, що дозволяє компіляторам оптимізувати код для паралельного виконання без необхідності складного апаратного забезпечення.
- Зосередженість на високому рівні інструкційної паралельності, з мінімальною підтримкою апаратного забезпечення.
- Використовується в архітектурах, де важливою є висока пропускна спроможність та масштабування.

**Приклади архітектур:** Intel Itanium - один з найвідоміших прикладів використання EPIC, розроблений спільно Intel і HP.

### SIMD (Single Instruction, Multiple Data)

**Основні характеристики:**

- Дозволяє одній інструкції обробляти кілька даних одночасно, значно збільшуючи пропускну спроможність при операціях над масивами або векторній обробці.
- Широко використовується в обчисленнях з високою продуктивністю та графічних процесорах для ефективної обробки зображень і відео.
- Сприяє ефективності виконання паралельних операцій, зокрема у наукових дослідженнях та обробці медіа.

**Приклади архітектур:** Майже всі сучасні процесори містять SIMD інструкції, такі як Intel AVX та AMD SSE.

### MIMD (Multiple Instruction, Multiple Data)

**Основні характеристики:**

- Кожен процесор або ядро в системі може виконувати різні інструкції над різними даними, що дозволяє високий ступінь паралелізму.
- Широко використовується в багатопроцесорних системах, кластерах та суперкомп'ютерах для вирішення складних обчислювальних задач.
- Підтримка складної логіки програмування та вимагає ефективного управління паралелізмом на рівні програмного забезпечення.

**Приклади архітектур:** Багато сучасних суперкомп'ютерів використовують MIMD архітектуру для досягнення екстремальних рівнів продуктивності, наприклад, системи на основі Intel Xeon або AMD EPYC.

### Продуктивність та Ефективність

- **RISC** архітектури мають перевагу у швидкості на такт завдяки своєму спрощеному пайплайнінгу і фіксованій довжині інструкцій, що забезпечує високу пропускну спроможність і швидкість виконання програм.
- **CISC** архітектури ефективно використовують пам'ять завдяки можливості виконувати складні операції за допомогою однієї інструкції, що може зменшити кількість необхідних інструкцій для виконання програми.
- **VLIW** та **EPIC** оптимізують паралельне виконання інструкцій на рівні компілятора, дозволяючи досягати високої продуктивності в обчислювальних задачах, де можливе значне паралелізування.
- **SIMD** і **MIMD** архітектури використовуються для задач, що вимагають обробки великих масивів даних або високого ступеня паралелізму на рівні даних та інструкцій, відповідно, забезпечуючи ефективність у специфічних областях застосування.

### Споживання Енергії

- **RISC** архітектури зазвичай є більш енергоефективними порівняно з CISC, що робить їх ідеальними для використання в мобільних та вбудованих системах.
- **VLIW** і **EPIC** можуть мати вище споживання енергії через потребу в обробці довгих інструкцій та високому рівні паралелізму, але це компенсується високою продуктивністю у певних задачах.

### Компіляція

- **CISC** архітектури можуть зменшити навантаження на компілятор завдяки можливості виконання складних операцій за одну інструкцію, але це також може ускладнити оптимізацію коду.
- **RISC**, **VLIW** та **EPIC** покладаються на оптимізації на рівні компілятора для досягнення максимальної продуктивності, що вимагає високої якості компіляторів.

### Області Застосування

- **RISC** ідеально підходить для мобільних та вбудованих систем, де важлива енергоефективність та простота реалізації.
- **CISC** залишається популярним у персональних комп'ютерах та серверах завдяки високій сумісності та здатності ефективно виконувати складні програми.
- **VLIW** і **EPIC** знаходять застосування в областях, де важлива максимальна продуктивність та можливість використання великого паралелізму, таких як високопродуктивні обчислення.
- **SIMD** використовується у графічних процесорах та обчисленнях, що вимагають обробки великих обсягів даних, тоді як **MIMD** підходить для багатозадачних та розподілених систем, де кожен процес або потік може виконувати різні задачі паралельно.

В архітектурі набору інструкцій (ISA) інструкції зазвичай класифікуються за типами операцій, які вони виконують. Ось декілька основних типів інструкцій:

### Арифметичні інструкції

Ці інструкції виконують базові арифметичні операції, такі як додавання, віднімання, множення та ділення. Вони можуть застосовуватися до цілих чисел, чисел з плаваючою комою, а іноді і до фіксованої коми.

### Логічні інструкції

Логічні інструкції виконують бітові операції над даними, такі як І (AND), АБО (OR), ВИКЛЮЧНО АБО (XOR) та НЕ (NOT). Ці інструкції корисні для маніпуляцій з бітами та реалізації логічних умов.

### Інструкції зсуву

Інструкції зсуву зміщують біти в операндах вліво або вправо, що може використовуватися для швидкого множення або ділення на степені двійки або для реалізації комплексних логічних функцій.

### Інструкції доступу до пам'яті

Ці інструкції забезпечують зчитування даних з пам'яті або запис даних у пам'ять. Вони включають інструкції завантаження (зчитування) та збереження (запису), що дозволяє процесору взаємодіяти з оперативною пам'яттю.

### Інструкції умовного переходу

Інструкції умовного переходу змінюють послідовність виконання інструкцій на основі заданої умови. Це ключові інструкції для реалізації циклів, умовних виразів та контролю потоку програми.

### Інструкції виклику функцій

Ці інструкції управляють викликом і поверненням з підпрограм. Вони включають в себе виклик підпрограми (CALL) та повернення з підпрограми (RET), спрощуючи структурурізацію коду та переиспользование коду.

### Інструкції безпосереднього управління

Ці інструкції впливають на внутрішній стан процесора або виконують спеціалізовані операції управління, такі як зміна режиму роботи процесора, включення/виключення переривань тощо.

Формати інструкцій в архітектурі набору інструкцій (ISA) визначають, як інструкції кодуються у бінарному вигляді для виконання процесором. Вони є ключовими для розуміння того, як команди представлені у пам'яті та як процесор інтерпретує ці команди. Існує декілька основних форматів інструкцій, які зазвичай використовуються в різних архітектурах:

### Формати інструкцій з фіксованою довжиною

У цьому форматі всі інструкції мають однакову довжину, що спрощує декодування інструкцій і дозволяє ефективніше використовувати пайплайн процесора. Формат з фіксованою довжиною є характерним для RISC-архітектур, таких як ARM і MIPS.

### Формати інструкцій зі змінною довжиною

В архітектурах з інструкціями зі змінною довжиною, таких як x86, інструкції можуть мати різну довжину. Це дозволяє компактніше кодувати часто використовувані інструкції, але робить декодування складнішим і може ускладнювати пайплайн процесування.

### Триадресний формат

Інструкції містять три операнди, де зазвичай два є вхідними операндами, а третій — результатом операції. Цей формат є досить гнучким і дозволяє прямо вказувати на регістри або адреси пам'яті.

### Двоадресний формат

У цьому форматі інструкція містить два операнди, один з яких слугує одночасно і вхідним операндом, і місцем збереження результату. Це спрощує структуру інструкції, але може обмежувати гнучкість.

### Одноадресний формат

Інструкції мають лише один операнд, а другий операнд (або результат) зазвичай зберігається в певному регістрі, наприклад, в аккумуляторі. Цей формат спрощує інструкції, але може вимагати додаткових інструкцій для переміщення даних між регістрами.

### Безадресний формат

Використовується в стекових архітектурах, де інструкції не містять явних операндів, а оперують з вершинами стеку. Це дозволяє дуже компактно кодувати інструкції, але ефективність такого підходу залежить від конкретних задач.

### Вибір формату інструкцій

Вибір між цими форматами залежить від багатьох факторів, включаючи цілі проектування архітектури, очікувану продуктивність, складність декодера інструкцій та цільові застосування. Формат інструкцій впливає на ефективність виконання програм та на складність процесорного дизайну.

Режими адресації в архітектурі набору інструкцій (ISA) визначають, як процесор визначає адресу даних, до яких потрібно звернутися. Режим адресації впливає на гнучкість та ефективність доступу до даних у пам'яті або до регістрів. Ось декілька основних режимів адресації, які зустрічаються в більшості архітектур:

### Пряма (або абсолютна) адресація

Адреса операнда вказується безпосередньо в інструкції. Це дозволяє простий доступ до даних, але обмежує дальність адресації розміром інструкції.

### Непряма адресація

Адреса операнда зберігається у регістрі або пам'яті. Інструкція містить вказівник на місце, де знаходиться реальна адреса. Це дозволяє динамічно змінювати адреси доступу до даних.

### Регістрова адресація

Операнд знаходиться безпосередньо в регістрі, ідентифікатор якого вказаний в інструкції. Це забезпечує швидкий доступ до даних, оскільки регістри є найшвидшою формою пам'яті.

### Регістрово-непряма адресація

Адреса операнда знаходиться в пам'яті, причому її базова адреса вказується через регістр. Часто використовується разом з відносним зміщенням для доступу до елементів масивів та структур даних.

### Індексна адресація

До базової адреси, вказаної в інструкції або регістрі, додається індекс, що дозволяє звертатися до елементів масиву. Індекс може зберігатися в іншому регістрі або вказуватися безпосередньо в інструкції.

### Базова адресація

Схожа на індексну адресацію, але використовується для доступу до даних, розміщених з певним зміщенням відносно базової адреси, яка зберігається в регістрі. Це корисно для роботи зі структурами даних.

### Відносна адресація

Адреса операнда визначається як зміщення відносно поточної позиції інструкції. Це особливо корисно для реалізації стрибків і викликів функцій.

### Непряма адресація з автоінкрементом та автодекрементом

Після доступу до операнда вказівник на адресу автоматично збільшується або зменшується на заданий крок. Це корисно для послідовного доступу до елементів масиву або стеку.

Кожен режим адресації має свої переваги та використовується в залежності від потреби оптимізації доступу до даних або специфіки виконуваних операцій.
